/// <reference types="node" />
import { EthAddress, GrumpkinAddress } from '@aztec/barretenberg/address';
import { AssetId } from '@aztec/barretenberg/asset';
import { EthereumSigner, PermitArgs, Receipt, TxType } from '@aztec/barretenberg/blockchain';
import { BridgeId } from '@aztec/barretenberg/bridge_id';
import { SettlementTime } from '@aztec/barretenberg/rollup_provider';
import { TxHash } from '@aztec/barretenberg/tx_hash';
import { ClientEthereumBlockchain, EthereumProvider } from '@aztec/blockchain';
import { EventEmitter } from 'events';
import { CoreSdk } from '../core_sdk/core_sdk';
import { SdkOptions } from '../core_sdk/create_sdk';
import { ProofOutput } from '../proofs/proof_output';
import { SdkEvent, SdkInitState } from '../sdk';
import { Signer } from '../signer';
import { AccountId, RecoveryPayload } from '../user';
import { WalletSdkUser } from './wallet_sdk_user';
export * from '@aztec/barretenberg/asset';
export * from './wallet_sdk_user';
export * from './wallet_sdk_user_asset';
export declare function createWalletSdk(ethereumProvider: EthereumProvider, serverUrl: string, sdkOptions?: SdkOptions): Promise<WalletSdk>;
export interface WalletSdk {
    on(event: SdkEvent.LOG, listener: (msg: string) => void): this;
    on(event: SdkEvent.UPDATED_INIT_STATE, listener: (initState: SdkInitState, message?: string) => void): this;
    on(event: SdkEvent.UPDATED_USERS, listener: () => void): this;
    on(event: SdkEvent.UPDATED_USER_STATE, listener: (userId: AccountId) => void): this;
    on(event: SdkEvent.UPDATED_WORLD_STATE, listener: (rollupId: number, latestRollupId: number) => void): this;
}
export declare class WalletSdk extends EventEmitter {
    private core;
    private blockchain;
    private ethSigner;
    private sdkOptions;
    constructor(core: CoreSdk, blockchain: ClientEthereumBlockchain, ethSigner: EthereumSigner, sdkOptions?: SdkOptions);
    static create(ethereumProvider: EthereumProvider, serverUrl: string, sdkOptions?: SdkOptions): Promise<WalletSdk>;
    init(): Promise<void>;
    destroy(): Promise<void>;
    awaitSynchronised(): Promise<void>;
    isUserSynching(userId: AccountId): boolean;
    awaitUserSynchronised(userId: AccountId): Promise<void>;
    awaitSettlement(txHash: TxHash, timeout?: number): Promise<void>;
    getLocalStatus(): {
        chainId: number;
        rollupContractAddress: EthAddress;
        syncedToRollup: number;
        latestRollupId: number;
        initState: SdkInitState;
        dataSize: number;
        dataRoot: Buffer;
        assets: import("@aztec/barretenberg/blockchain").BlockchainAsset[];
    };
    getRemoteStatus(): Promise<import("@aztec/barretenberg/rollup_provider").RollupProviderStatus>;
    getFee(assetId: AssetId, txType: TxType, speed?: SettlementTime): Promise<bigint>;
    getUserPendingDeposit(assetId: AssetId, account: EthAddress): Promise<bigint>;
    getAddressFromAlias(alias: string, nonce?: number): Promise<GrumpkinAddress | undefined>;
    getLatestUserNonce(publicKey: GrumpkinAddress): Promise<number>;
    isAliasAvailable(alias: string): Promise<boolean>;
    mint(assetId: AssetId, value: bigint, account: EthAddress, provider?: EthereumProvider): Promise<TxHash>;
    approve(assetId: AssetId, value: bigint, account: EthAddress, provider?: EthereumProvider): Promise<TxHash>;
    createPermitData(assetId: AssetId, from: EthAddress, value: bigint, deadline: bigint): Promise<import("@aztec/barretenberg/blockchain").TypedData>;
    createPermitArgs(assetId: AssetId, from: EthAddress, value: bigint, deadline?: bigint, provider?: EthereumProvider): Promise<PermitArgs>;
    createDepositProof(assetId: AssetId, from: EthAddress, to: AccountId, value: bigint, fee: bigint, signer: Signer): Promise<import("../proofs/proof_output").JoinSplitProofOutput>;
    createWithdrawProof(assetId: AssetId, userId: AccountId, value: bigint, fee: bigint, signer: Signer, to: EthAddress): Promise<import("../proofs/proof_output").JoinSplitProofOutput>;
    createTransferProof(assetId: AssetId, userId: AccountId, value: bigint, fee: bigint, signer: Signer, to: AccountId): Promise<import("../proofs/proof_output").JoinSplitProofOutput>;
    createJoinSplitProof(assetId: AssetId, userId: AccountId, publicInput: bigint, publicOutput: bigint, privateInput: bigint, recipientPrivateOutput: bigint, senderPrivateOutput: bigint, signer: Signer, noteRecipient?: AccountId, inputOwner?: EthAddress, outputOwner?: EthAddress): Promise<import("../proofs/proof_output").JoinSplitProofOutput>;
    createAccountProof(userId: AccountId, signer: Signer, alias: string, nonce: number, migrate: boolean, newSigningPublicKey1?: GrumpkinAddress, newSigningPublicKey2?: GrumpkinAddress, newAccountPrivateKey?: Buffer): Promise<import("../proofs/proof_output").AccountProofOutput>;
    createDefiProof(bridgeId: BridgeId, userId: AccountId, depositValue: bigint, txFee: bigint, signer: Signer): Promise<import("../proofs/proof_output").DefiProofOutput>;
    signProof(proofOutput: ProofOutput, inputOwner: EthAddress, provider?: EthereumProvider): Promise<Buffer>;
    sendProof(proofOutput: ProofOutput, signature?: Buffer): Promise<TxHash>;
    approveProof(address: EthAddress, signingData: Buffer, provider?: EthereumProvider): Promise<TxHash>;
    depositFundsToContract(assetId: AssetId, from: EthAddress, value: bigint, permitArgs?: PermitArgs, provider?: EthereumProvider): Promise<TxHash>;
    getTransactionReceipt(txHash: TxHash, interval?: number, timeout?: number): Promise<Receipt>;
    isContract(address: EthAddress): Promise<boolean>;
    isProofApproved(account: EthAddress, signingData: Buffer): Promise<boolean>;
    private checkNoteBalance;
    generateAccountRecoveryData(alias: string, publicKey: GrumpkinAddress, trustedThirdPartyPublicKeys: GrumpkinAddress[], nonce?: number): Promise<RecoveryPayload[]>;
    createAccount(userId: AccountId, alias: string, newSigningPublicKey: GrumpkinAddress, recoveryPublicKey?: GrumpkinAddress): Promise<TxHash>;
    recoverAccount(recoveryPayload: RecoveryPayload): Promise<TxHash>;
    migrateAccount(userId: AccountId, signer: Signer, newSigningPublicKey: GrumpkinAddress, recoveryPublicKey?: GrumpkinAddress, newAccountPrivateKey?: Buffer): Promise<TxHash>;
    addSigningKeys(userId: AccountId, signer: Signer, signingPublicKey1: GrumpkinAddress, signingPublicKey2?: GrumpkinAddress): Promise<TxHash>;
    getSigningKeys(userId: AccountId): Promise<Buffer[]>;
    userExists(userId: AccountId): Promise<boolean>;
    getUserData(userId: AccountId): import("../user").UserData;
    getUsersData(): import("../user").UserData[];
    createSchnorrSigner(privateKey: Buffer): import("../signer").SchnorrSigner;
    addUser(privateKey: Buffer, nonce?: number, noSync?: boolean): Promise<WalletSdkUser>;
    removeUser(userId: AccountId): Promise<void>;
    /**
     * Returns a WalletSdkUser for a locally resolved user.
     */
    getUser(userId: AccountId): WalletSdkUser;
    getBalance(assetId: AssetId, userId: AccountId): bigint;
    getMaxSpendableValue(assetId: AssetId, userId: AccountId): Promise<bigint>;
    getSpendableNotes(assetId: AssetId, userId: AccountId): Promise<import("..").Note[]>;
    getSpendableSum(assetId: AssetId, userId: AccountId): Promise<bigint>;
    getPublicBalance(assetId: AssetId, ethAddress: EthAddress): Promise<bigint>;
    getPublicAllowance(assetId: AssetId, ethAddress: EthAddress): Promise<bigint>;
    fromBaseUnits(assetId: AssetId, value: bigint, precision?: number): string;
    toBaseUnits(assetId: AssetId, value: string): bigint;
    getAssetInfo(assetId: AssetId): import("@aztec/barretenberg/blockchain").BlockchainAsset;
    getJoinSplitTxs(userId: AccountId): Promise<import("..").UserJoinSplitTx[]>;
    getAccountTxs(userId: AccountId): Promise<import("..").UserAccountTx[]>;
    getDefiTxs(userId: AccountId): Promise<import("..").UserDefiTx[]>;
    getNotes(userId: AccountId): Promise<import("..").Note[]>;
    derivePublicKey(privateKey: Buffer): GrumpkinAddress;
    validateSignature(publicOwner: EthAddress, signature: Buffer, signingData: Buffer): boolean;
    /**
     * Returns a globally resolved AccountId.
     */
    getAccountId(aliasOrAddress: string | GrumpkinAddress, nonce?: number): Promise<AccountId>;
    private sendAccountProof;
}
//# sourceMappingURL=index.d.ts.map