/// <reference types="node" />
import { AliasHash } from '@aztec/barretenberg/account_id';
import { EthAddress, GrumpkinAddress } from '@aztec/barretenberg/address';
import { AssetId } from '@aztec/barretenberg/asset';
import { TxType } from '@aztec/barretenberg/blockchain';
import { BridgeId } from '@aztec/barretenberg/bridge_id';
import { RollupProvider, SettlementTime } from '@aztec/barretenberg/rollup_provider';
import { TxHash } from '@aztec/barretenberg/tx_hash';
import { EventEmitter } from 'events';
import { LevelUp } from 'levelup';
import { Database } from '../database';
import { AccountProofOutput, DefiProofOutput, JoinSplitProofOutput, ProofOutput } from '../proofs/proof_output';
import { SdkInitState } from '../sdk';
import { SchnorrSigner, Signer } from '../signer';
import { AccountId, UserData } from '../user';
import { UserAccountTx, UserDefiTx, UserJoinSplitTx } from '../user_tx';
/**
 * These are events that are only emitted due to changes triggered within the current execution context.
 * Primarily, these are hooked into a broadcast channel to notify other instances of state changes.
 * Treat CoreSdkEvents as events for synchronising state between SDK instances, and SdkEvents for notifying UI changes.
 */
export declare enum CoreSdkEvent {
    UPDATED_WORLD_STATE = "CORESDKEVENT_UPDATED_WORLD_STATE",
    UPDATED_USERS = "CORESDKEVENT_UPDATED_USERS",
    UPDATED_USER_STATE = "CORESDKEVENT_UPDATED_USER_STATE"
}
export interface CoreSdkOptions {
    saveProvingKey?: boolean;
}
export declare class CoreSdk extends EventEmitter {
    private leveldb;
    private db;
    private rollupProvider;
    private options;
    private worldState;
    private userStates;
    private workerPool;
    private joinSplitProofCreator;
    private accountProofCreator;
    private blockQueue;
    private userFactory;
    private userStateFactory;
    private mutex;
    private numCPU;
    private sdkStatus;
    private processBlocksPromise?;
    private blake2s;
    private pedersen;
    private schnorr;
    private grumpkin;
    constructor(leveldb: LevelUp, db: Database, rollupProvider: RollupProvider, options: CoreSdkOptions);
    private nextLowestPowerOf2;
    init(): Promise<void>;
    getRollupContractAddress(): Promise<EthAddress | undefined>;
    eraseDb(): Promise<void>;
    private getCrsData;
    /**
     * Shutdown any existing `UserState` instances and wait for them to complete any processing.
     * Load the users from the database and create and initialize their new user states.
     * Emit SdkEvent.UPDATED_USERS to update the UI containing any user lists.
     * Emit SdkEvent.UPDATED_USER_STATE to update the UI for each user.
     * Register for changes to each user state and emit appropriate events.
     * If this SDK instance is handling blocks, start syncing the user states.
     *
     * Public, as it will be called in the event of another instance emitting CoreSdkEvent.UPDATED_USERS.
     */
    initUserStates(): Promise<void>;
    private startSyncingUserState;
    private stopSyncingUserStates;
    private createJoinSplitProvingKey;
    private createAccountProvingKey;
    destroy(): Promise<void>;
    private updateInitState;
    getLocalStatus(): {
        chainId: number;
        rollupContractAddress: EthAddress;
        syncedToRollup: number;
        latestRollupId: number;
        initState: SdkInitState;
        dataSize: number;
        dataRoot: Buffer;
        assets: import("@aztec/barretenberg/blockchain").BlockchainAsset[];
    };
    private logInitMsgAndDebug;
    getRemoteStatus(): Promise<import("@aztec/barretenberg/rollup_provider").RollupProviderStatus>;
    getFee(assetId: AssetId, transactionType: TxType, speed: SettlementTime): Promise<bigint>;
    startReceivingBlocks(): Promise<void>;
    private sync;
    private updateStatusRollupInfo;
    private stopReceivingBlocks;
    private processBlockQueue;
    private processAliases;
    /**
     * Called when another instance of the sdk has updated the world state db.
     */
    notifyWorldStateUpdated(): Promise<void>;
    /**
     * Called when another instance of the sdk has updated a users state.
     * Call the user state init function to refresh users internal state.
     * Emit an SdkEvent to update the UI.
     */
    notifyUserStateUpdated(userId: AccountId, balanceAfter?: bigint, diff?: bigint, assetId?: AssetId): Promise<void>;
    /**
     * Return the latest nonce for a given public key, derived from chain data.
     */
    getLatestUserNonce(publicKey: GrumpkinAddress): Promise<number>;
    getAddressFromAlias(alias: string, nonce?: number): Promise<GrumpkinAddress | undefined>;
    getAccountId(user: string | GrumpkinAddress, nonce?: number): Promise<AccountId>;
    isAliasAvailable(alias: string): Promise<boolean>;
    computeAliasHash(alias: string): AliasHash;
    createSchnorrSigner(privateKey: Buffer): SchnorrSigner;
    createJoinSplitProof(assetId: AssetId, userId: AccountId, publicInput: bigint, publicOutput: bigint, privateInput: bigint, recipientPrivateOutput: bigint, senderPrivateOutput: bigint, signer: Signer, noteRecipient?: AccountId, inputOwner?: EthAddress, outputOwner?: EthAddress): Promise<JoinSplitProofOutput>;
    createAccountTx(signer: Signer, alias: string, nonce: number, migrate: boolean, accountPublicKey: GrumpkinAddress, newAccountPublicKey?: GrumpkinAddress, newSigningPubKey1?: GrumpkinAddress, newSigningPubKey2?: GrumpkinAddress): Promise<import("@aztec/barretenberg/client_proofs").AccountTx>;
    createAccountProof(userId: AccountId, signer: Signer, aliasHash: AliasHash, nonce: number, migrate: boolean, newSigningPublicKey1?: GrumpkinAddress, newSigningPublicKey2?: GrumpkinAddress, newAccountPrivateKey?: Buffer): Promise<AccountProofOutput>;
    createDefiProof(bridgeId: BridgeId, userId: AccountId, depositValue: bigint, txFee: bigint, signer: Signer): Promise<DefiProofOutput>;
    sendProof(proofOutput: ProofOutput, depositSignature?: Buffer): Promise<TxHash>;
    private isSynchronised;
    awaitSynchronised(): Promise<void>;
    isUserSynching(userId: AccountId): boolean;
    awaitUserSynchronised(userId: AccountId): Promise<void>;
    awaitSettlement(txHash: TxHash, timeout?: number): Promise<void>;
    private getUserState;
    userExists(userId: AccountId): Promise<boolean>;
    getUserData(userId: AccountId): UserData;
    getUsersData(): UserData[];
    derivePublicKey(privateKey: Buffer): GrumpkinAddress;
    addUser(privateKey: Buffer, nonce?: number, noSync?: boolean): Promise<UserData>;
    private addUserFromUserData;
    removeUser(userId: AccountId): Promise<void>;
    getSigningKeys(accountId: AccountId): Promise<Buffer[]>;
    getBalance(assetId: AssetId, userId: AccountId): bigint;
    getMaxSpendableValue(assetId: AssetId, userId: AccountId): Promise<bigint>;
    getSpendableNotes(assetId: AssetId, userId: AccountId): Promise<import("..").Note[]>;
    getSpendableSum(assetId: AssetId, userId: AccountId): Promise<bigint>;
    getJoinSplitTxs(userId: AccountId): Promise<UserJoinSplitTx[]>;
    getAccountTxs(userId: AccountId): Promise<UserAccountTx[]>;
    getDefiTxs(userId: AccountId): Promise<UserDefiTx[]>;
    getNotes(userId: AccountId): Promise<import("..").Note[]>;
}
//# sourceMappingURL=core_sdk.d.ts.map