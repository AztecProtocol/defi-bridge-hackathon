/// <reference types="node" />
import { AssetId } from '@aztec/barretenberg/asset';
import { Block } from '@aztec/barretenberg/block_source';
import { Pedersen } from '@aztec/barretenberg/crypto';
import { Grumpkin } from '@aztec/barretenberg/ecc';
import { NoteAlgorithms } from '@aztec/barretenberg/note_algorithms';
import { RollupProvider } from '@aztec/barretenberg/rollup_provider';
import { EventEmitter } from 'events';
import { Database } from '../database';
import { Note } from '../note';
import { UserData } from '../user';
import { UserAccountTx, UserDefiTx, UserJoinSplitTx } from '../user_tx';
export declare enum UserStateEvent {
    UPDATED_USER_STATE = "UPDATED_USER_STATE"
}
export declare class UserState extends EventEmitter {
    private user;
    private grumpkin;
    private pedersen;
    private noteAlgos;
    private db;
    private rollupProvider;
    private notePickers;
    private blockQueue;
    private syncState;
    private syncingPromise;
    constructor(user: UserData, grumpkin: Grumpkin, pedersen: Pedersen, noteAlgos: NoteAlgorithms, db: Database, rollupProvider: RollupProvider);
    /**
     * Load/refresh user state.
     */
    init(): Promise<void>;
    /**
     * First handles all historical blocks.
     * Then starts processing blocks added to queue via `processBlock()`.
     */
    startSync(): Promise<void>;
    /**
     * Stops processing queued blocks. Blocks until any processing is complete.
     */
    stopSync(flush?: boolean): Promise<void> | undefined;
    isSyncing(): boolean;
    getUser(): UserData;
    processBlock(block: Block): void;
    handleBlocks(blocks: Block[]): Promise<void>;
    private handleAccountTx;
    private handleJoinSplitTx;
    private handleDefiDepositTx;
    private handleDefiClaimTx;
    private processNewNote;
    private nullifyNote;
    private addClaim;
    private recoverJoinSplitTx;
    private recoverAccountTx;
    private recoverDefiTx;
    private refreshNotePicker;
    pickNotes(assetId: AssetId, value: bigint): Promise<Note[] | null>;
    getSpendableNotes(assetId: AssetId): Promise<Note[]>;
    getSpendableSum(assetId: AssetId): Promise<bigint>;
    getMaxSpendableValue(assetId: AssetId): Promise<bigint>;
    getBalance(assetId: AssetId): bigint;
    addTx(tx: UserJoinSplitTx | UserAccountTx | UserDefiTx): Promise<void>;
    awaitSynchronised(): Promise<void>;
}
export declare class UserStateFactory {
    private grumpkin;
    private pedersen;
    private noteAlgos;
    private db;
    private rollupProvider;
    constructor(grumpkin: Grumpkin, pedersen: Pedersen, noteAlgos: NoteAlgorithms, db: Database, rollupProvider: RollupProvider);
    createUserState(user: UserData): UserState;
}
//# sourceMappingURL=index.d.ts.map